
---
## 问题代码

```python
for name in name_list:
    del name_list[0]
```

目标：在遍历过程中删除列表元素。

---

## 1. 现象

当列表长度为 `n` 时：

- 并不会删除全部元素
    
- 最终会**剩余约一半元素**
    
- 剩余的是**原列表的后半段**


示例：

|初始长度 n|删除次数|剩余元素|
|---|---|---|
|3|2|1|
|4|2|2|
|5|3|2|
|10|5|5|

---

## 2. 机制分析

### (1) Python `for` 循环的本质

```text
for x in list
```

等价于：

```text
使用 list iterator，内部维护递增索引 i = 0,1,2,...
每次读取 list[i]
```

---

### (2) 删除操作的副作用

```python
del list[0]
```

导致：

- 所有后续元素左移一位
    
- 长度减少 1

即发生：

```text
Index Shifting（索引左移）
```

---

### (3) 冲突模型

每一轮：

- 迭代器索引：`i = t`
    
- 当前列表长度：`L = n - t`
    

循环继续的条件：

	  `i < L = n - t`

---

## 3. 数学推导结论

### 删除轮数

满足：

	2t < n  

的整数 `t` 个数为：

	m =  n/2 


### 剩余元素数

	n - m = n/2  

---

## 4. n = 10 的具体推导

初始：

```
[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9]
```

删除过程（始终删除头部）：

|轮次|删除元素|
|---|---|
|1|a0|
|2|a1|
|3|a2|
|4|a3|
|5|a4|

最终剩余：

```
[a5,a6,a7,a8,a9]
```

---

## 5. 抽象结论

> 在遍历列表时删除头部元素，会删除原列表的前 ⌈n/2⌉ 个元素，并保留后 ⌊n/2⌋ 个元素。

---

## 6. 关键概念标注

```text
Iterator Invalidation
容器结构在遍历期间发生改变，导致迭代器内部索引与实际数据布局不同步。
```

```text
Index Shifting
删除元素后，后续元素索引整体前移。
```

---

## 7. 正确删除整个列表的方法

|方法|代码|
|---|---|
|原地清空（推荐）|`list.clear()`|
|切片删除|`del list[:]`|
|while 删除|`while list: del list[0]`|

---

## 8. 实务准则

```text
Never mutate a list while iterating over it.
```

如必须删除：

- 倒序删除
    
- 或构造新列表
    
- 或使用 clear()


---

## 附：复杂度说明

- `del list[0]` → O(n)（连续数组整体搬移）
    
- 该写法总复杂度 → O(n²)

